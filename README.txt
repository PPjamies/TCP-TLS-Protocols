server generates a private key using openssl:
openssl genrsa -out server_private.pem 2048

server generates a certificate that contains:
- public key (derived from private key)
- metadata such as server hostname
- issuer details if signed by trusted certificate authority (CA)

for production, you can generate a certificate signing request (CSR) using the private key and submit it to a trusted CA:
openssl req -new -key server_private.pem -out server.csr

server can generate a self-signed certificate for testing:
openssl x509 -req -days 365 -in server.csr -signkey server_private.pem -out server_cert.pem

bundle private key and certificate into a .pfx file (PKCS#12 Format):
openssl pkcs12 -export -out identity.pfx -inkey server_private.key -in server.crt -certfile server.crt

TLS HANDSHAKE ORDER OF EXCHANGE (RSA)
- client sends:
    - supported tls versions
    - list of supported encryption algorithms
    - randomly generated "client random" (used for key generation)

- server responds:
    - selected tls version
    - selected encryption algorithm
    - randomly generated "server random"
    - server's certificate which includes public key

- client:
    - validates the server's certificate against a trusted CA
    - verifies the server's certificate matches the server's hostname

- client sends:
    - pre-master secret encrypted with the server's public key

- server:
    - decrypts pre-master secret using private key

- both client and server processes:
    - combine the pre-master secret and both random values (client_rand, server_rand)
    - pass combination to a key derivation function (KDF) to generate "session keys":
        - encryption key (symmetric key) (session key):
            - used for encrypting messages between the client and server
            - one key for encrypting client-to-server traffic and another for server-to-client traffic
        - mac key (message authentication keys):
            - used to verify the integrity and authenticity of messages
        - initialization vectors (IVs) (if needed)

client and server sends:
    - encrypted message indicating handshake completion

Notes:
    - client/server randoms are 32 bytes (256 bits) long
        - first 4 bytes is a UNIX timestamp representing current time
        - remaining 28 bytes are randomly generated bytes

    - pre-master secret is typically 48 bytes (384 bits) long
        - rsa:
            - client generates a 48-byte random value
            - value is encrypted using the server's public key
            - client sends value to server
            - example: pre_master_secret = [tls version (2 bytes)] + [46 bytes of rand data]
    - server can return multiple x509s:
        - server certificate
        - intermediate certificates – Certificates from intermediate Certificate Authorities (CAs) that link the server's certificate to a trusted root certificate
        - root certificate – trusted by the client (optional, as clients typically have a set of trusted root certificates)


AFTER TLS HANDSHAKE:
- summary:
    - client has:
        - public key (not used after handshake)
        - session keys
    - server has:
        - private key (not used after handshake)
        - session keys
    - both client and server have the SAME session keys

- client has:
    - session keys
    - message

- client will:
    - use the session encryption key to encrypt the message
    - compute a "message authentication code (MAC)" using its session MAC key
        - the MAC is used to verify the integrity and authenticity of the message, ensuring that it hasn't been tampered with
        - use HMAC (Hashed Message Authentication Code), which uses a secure hash algorithm (like SHA-256) combined with a "secret key" (session key).
    - (optional) generate an IV for encryption methods that require it

- client sends:
    - encrypted message:
        - encrypted data
        - MAC

- server receives encrypted message
- sever will:
    - check the MAC to see if its different, if so, discard the message because there's indication of tampering
    - use the session decryption key to decrypt message


EXAMPLE OF SERVER HANDSHAKE RESPONSE
Server Hello:
  Protocol Version: TLSv1.2
  Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA
  Session ID: [session_id]
  Server Random: [server_random_bytes]
  Server Hello Done

Server Certificate:
  Certificate: [certificate data]
    Version: 3
    Serial Number: [serial_number]
    Signature Algorithm: sha256WithRSAEncryption
    Issuer: [issuer information]
    Subject: [server subject information]
    Validity: [valid_from] to [valid_to]
    Public Key: [server public key]

Server Key Exchange (optional depending on cipher):
  Modulus: [modulus]
  Public Exponent: [public_exponent]
  Signature: [signature]

Server Hello Done